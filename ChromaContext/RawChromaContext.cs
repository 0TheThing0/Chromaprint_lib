using Chromaprint.Compression;
using Chromaprint.FFT;
using Chromaprint.Fingerprint;
using Chromaprint.Utilities;

namespace Chromaprint;

public class RawChromaContext : IRawChromaContext
{
    private readonly RawFingerprinter _fingerprinter;
    private IFFTService _fftService;
    private int[] _fingerprint;


    public string Version => "100.0.0";
    public FingerprintAlgorithm Algorithm { get; }

    public RawChromaContext()
        : this(FingerprintAlgorithm.FP2)
    {
    }

    public RawChromaContext(IFFTService fftService)
        : this(FingerprintAlgorithm.FP2, fftService)
    {
    }

    public RawChromaContext(FingerprintAlgorithm algorithm)
        : this(FingerprintAlgorithm.FP2, new LomontFFTService())
    {
    }

    public RawChromaContext(FingerprintAlgorithm algorithm, IFFTService fftService)
    {
        _fingerprint = Array.Empty<int>();
        Algorithm = algorithm;
        _fftService = fftService;

        var config = FingerprinterConfiguration.CreateConfiguration(algorithm);
        _fingerprinter = new RawFingerprinter(config, fftService);
    }

    /// <summary>
    ///     Set a configuration option for the selected fingerprint algorithm.
    /// </summary>
    /// <param name="name">option name</param>
    /// <param name="value">option value</param>
    /// <returns>False on error, true on success</returns>
    /// <remarks>
    ///     NOTE: DO NOT USE THIS FUNCTION IF YOU ARE PLANNING TO USE
    ///     THE GENERATED FINGERPRINTS WITH THE ACOUSTID SERVICE.
    ///     Possible options:
    ///     - silence_threshold: threshold for detecting silence, 0-32767
    /// </remarks>
    public bool SetOption(string name, int value)
    {
        return _fingerprinter.SetOption(name, value);
    }

    /// <summary>
    ///     Restart the computation of a fingerprint with a new audio stream
    /// </summary>
    /// <param name="sampleRate">Sample rate of the audio stream (in Hz)</param>
    /// <param name="numChannels">Number of channels in the audio stream (1 or 2)</param>
    /// <returns>False on error, true on success</returns>
    public bool Start(int sampleRate, int numChannels)
    {
        return _fingerprinter.Start(sampleRate, numChannels);
    }

    /// <summary>
    ///     Send audio data to the fingerprint calculator (alias to Feed() method)
    /// </summary>
    /// <param name="input">
    ///     Raw audio data (array of 16-bit signed integers
    ///     in native byte-order)
    /// </param>
    /// <param name="length">
    ///     Size of the data buffer (in samples)
    /// </param>
    public void Consume(short[] input, int length)
    {
        Feed(input, length);
    }

    /// <summary>
    ///     Send audio data to the fingerprint calculator
    /// </summary>
    /// <param name="data">
    ///     Raw audio data (array of 16-bit signed integers
    ///     in native byte-order)
    /// </param>
    /// <param name="size">
    ///     Size of the data buffer (in samples)
    /// </param>
    public void Feed(short[] data, int size)
    {
        _fingerprinter.Consume(data, size);
    }

    /// <summary>
    ///     Process any remaining buffered audio data
    ///     and calculate the fingerprint
    /// </summary>
    public void Finish()
    {
        _fingerprint = _fingerprinter.Finish();
    }

    /// <summary>
    ///     Return the calculated fingerprint as a compressed string.
    /// </summary>
    /// <returns>The fingerprint as a compressed string</returns>
    public string GetFingerprint()
    {
        var compressor = new FingerprintCompressor();
        return ChromaBase64.Encode(compressor.Compress(_fingerprint, (int)Algorithm));
    }

    /// <summary>
    ///     Return the calculated fingerprint as an array of 32-bit integers.
    /// </summary>
    /// <returns>The raw fingerprint (array of 32-bit integers)</returns>
    public int[] GetRawFingerprint()
    {
        var size = _fingerprint.Length;
        var fp = new int[size];

        Array.Copy(_fingerprint, 0, fp, 0, size);
        return fp;
    }

    /// <summary>
    ///     Return 32-bit hash of the calculated fingerprint
    /// </summary>
    /// <returns>The hash</returns>
    /// <remarks>
    ///     If two fingerprints are similar, their hashes generated by this function
    ///     will also be similar. If they are significantly different, their hashes
    ///     will most likely be significantly different as well, but you can't rely
    ///     on that.
    ///     You compare two hashes by counting the bits in which they differ. Normally
    ///     that would be something like POPCNT(hash1 XOR hash2), which returns a
    ///     number between 0 and 32. Anthing above 15 means the hashes are
    ///     completely different.
    /// </remarks>
    public int GetFingerprintHash()
    {
        return SimHash.Compute(_fingerprint);
    }
}